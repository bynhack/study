<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº¤äº’å¼åŸºç¡€å½¢çŠ¶å­¦ä¹ </title>
    <style>
        /* --- å…¨å±€æ ·å¼ (ä¸ä¹‹å‰ç±»ä¼¼ï¼Œç•¥ä½œè°ƒæ•´) --- */
        :root {
            --primary-color: #4a90e2; /* ä¸»é¢˜è“ */
            --secondary-color: #f5a623; /* å¼ºè°ƒæ©™ */
            --handle-color: #e91e63; /* æ‹–åŠ¨ç‚¹é¢œè‰² */
            --background-color: #f4f7f6;
            --panel-background: #ffffff;
            --text-color: #333333;
            --light-text-color: #666666;
            --border-color: #e0e0e0;
            --font-family: 'Helvetica Neue', Arial, 'Microsoft YaHei', sans-serif;
            --border-radius: 8px;
            --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding-top: 30px;
            box-sizing: border-box;
            user-select: none; /* é˜²æ­¢æ‹–åŠ¨æ—¶é€‰ä¸­æ–‡å­— */
        }

        .container {
            display: flex;
            width: 90%;
            max-width: 1200px;
            background-color: var(--panel-background);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            overflow: hidden;
        }

        .column {
            padding: 25px;
            box-sizing: border-box;
            height: auto;
        }

        .controls {
            flex: 1;
            border-right: 1px solid var(--border-color);
            background-color: #fafafa;
        }

        .demo-area {
            flex: 2;
            border-right: 1px solid var(--border-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 450px;
            position: relative;
            overflow: hidden; /* éšè—å¯èƒ½è¶…å‡ºè¾¹ç•Œçš„handle */
        }

        .explanation {
            flex: 1.5;
            background-color: #fdfdfd;
        }

        h2 {
            color: var(--primary-color);
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1.4em;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 8px;
        }

        .controls button {
            display: block;
            width: 100%;
            padding: 12px 15px;
            margin-bottom: 10px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            font-size: 1em;
            cursor: pointer;
            text-align: left;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }
        .controls button:hover { background-color: #3a7bc8; }
        .controls button:active { background-color: #2a5d9a; transform: scale(0.98); }
        .controls button.active { background-color: var(--secondary-color); font-weight: bold; }

        #shape-svg {
            width: 90%; /* ç¨å¾®å¢å¤§SVGåŒºåŸŸå æ¯” */
            max-width: 350px; /* å…è®¸ç¨å¤§å°ºå¯¸ */
            height: auto;
            aspect-ratio: 1 / 1;
            cursor: default; /* SVGèƒŒæ™¯é»˜è®¤å…‰æ ‡ */
            overflow: visible; /* ç¡®ä¿handleå¯è§ */
        }

        #initial-prompt {
            position: absolute;
            color: var(--light-text-color);
            font-style: italic;
            text-align: center;
        }

        .explanation h3 {
            color: var(--secondary-color);
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        .explanation p, .explanation ul {
            color: var(--text-color);
            line-height: 1.7;
            margin-bottom: 15px;
        }
        .explanation ul { padding-left: 20px; }
        .explanation li { margin-bottom: 8px; }

        /* å®æ—¶é¢ç§¯æ˜¾ç¤º */
        #area-display {
            margin-top: 20px;
            padding: 10px;
            background-color: #eef5fd;
            border-left: 4px solid var(--primary-color);
            border-radius: 4px;
        }
        #area-display strong {
            color: var(--primary-color);
            font-size: 1.1em;
        }
        #shape-area {
            font-weight: bold;
            color: var(--secondary-color);
        }

        /* SVGå½¢çŠ¶å’ŒHandleæ ·å¼ */
        .shape {
            stroke-width: 2; /* ç¨å¾®ç»†ä¸€ç‚¹ */
            stroke: #555;
            fill-opacity: 0.8; /* åŠé€æ˜å¡«å…… */
        }
        .handle {
            fill: var(--handle-color);
            stroke: #fff;
            stroke-width: 1.5;
            cursor: move; /* 'move' æˆ– 'grab' */
            transition: r 0.2s ease; /* åŠå¾„è¿‡æ¸¡ */
        }
        .handle:hover {
            r: 7; /* é¼ æ ‡æ‚¬åœæ—¶å˜å¤§ */
        }

        @media (max-width: 768px) {
            .container { flex-direction: column; width: 95%; }
            .column { border-right: none; border-bottom: 1px solid var(--border-color); }
            .explanation { border-bottom: none; }
            .demo-area { min-height: 300px; }
            #shape-svg { width: 70%; }
        }
    </style>
</head>
<body>

    <div class="container">
        <!-- å·¦æ ï¼šæ§åˆ¶é¢æ¿ -->
        <div class="column controls">
            <h2>é€‰æ‹©å½¢çŠ¶</h2>
            <button data-shape="square">æ­£æ–¹å½¢</button>
            <button data-shape="rectangle">é•¿æ–¹å½¢</button>
            <button data-shape="triangle">ä¸‰è§’å½¢</button>
            <button data-shape="parallelogram">å¹³è¡Œå››è¾¹å½¢</button>
            <button data-shape="trapezoid">æ¢¯å½¢</button>
        </div>

        <!-- ä¸­æ ï¼šæ¼”ç¤ºåŒºåŸŸ -->
        <div class="column demo-area">
            <div id="initial-prompt">è¯·ä»å·¦è¾¹é€‰æ‹©ä¸€ä¸ªå½¢çŠ¶ ğŸ˜Š</div>
            <svg id="shape-svg" viewBox="0 0 200 200" preserveAspectRatio="xMidYMid meet">
                <!-- SVG å½¢çŠ¶å’Œ Handle å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
            </svg>
        </div>

        <!-- å³æ ï¼šè®²è§£åŒºåŸŸ -->
        <div class="column explanation">
            <h2>å½¢çŠ¶çŸ¥è¯†</h2>
            <div id="explanation-content">
                <p>è¿™é‡Œä¼šæ˜¾ç¤ºä½ é€‰æ‹©çš„å½¢çŠ¶çš„ä»‹ç»å“¦ï¼</p>
            </div>
            <div id="area-display" style="display: none;">
                <strong>é¢ç§¯è®¡ç®—:</strong>
                <p>å½“å‰å½¢çŠ¶çš„é¢ç§¯å¤§çº¦æ˜¯ <span id="shape-area">?</span> ã€‚</p>
                <small>(é¢ç§¯æ˜¯ä¼°ç®—å€¼ï¼ŒåŸºäºå›¾å½¢åƒç´ )</small>
            </div>
        </div>
    </div>

    <script>
        const shapeButtons = document.querySelectorAll('.controls button');
        const svgContainer = document.getElementById('shape-svg');
        const explanationContent = document.getElementById('explanation-content');
        const initialPrompt = document.getElementById('initial-prompt');
        const areaDisplay = document.getElementById('area-display');
        const shapeAreaSpan = document.getElementById('shape-area');

        let currentShape = null;
        let draggedElement = null;
        let offset = { x: 0, y: 0 }; // é¼ æ ‡ç‚¹å‡»ä½ç½®ç›¸å¯¹äº handle ä¸­å¿ƒçš„åç§»
        let svgPoint = svgContainer.createSVGPoint(); // ç”¨äºåæ ‡è½¬æ¢

        // å°†å±å¹•åæ ‡è½¬æ¢ä¸ºSVGåæ ‡
        function getSVGPoint(event) {
            const pt = svgPoint;
            // å¤„ç†è§¦æ‘¸äº‹ä»¶å’Œé¼ æ ‡äº‹ä»¶
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            pt.x = clientX;
            pt.y = clientY;
            const svgRect = svgContainer.getBoundingClientRect();
            const matrix = svgContainer.getScreenCTM().inverse();
            return pt.matrixTransform(matrix);
        }

        // --- æ‹–åŠ¨é€»è¾‘ ---
        function startDrag(event) {
            // event.target æ˜¯è§¦å‘äº‹ä»¶çš„å…ƒç´  (handle)
            if (event.target.classList.contains('handle')) {
                draggedElement = event.target;
                const currentPos = getSVGPoint(event);
                // è®¡ç®—åç§»ï¼Œä½¿æ‹–åŠ¨æ›´è‡ªç„¶ï¼ˆä»åœ†å¿ƒå¼€å§‹æ‹–åŠ¨ï¼‰
                offset.x = currentPos.x - parseFloat(draggedElement.getAttribute('cx'));
                offset.y = currentPos.y - parseFloat(draggedElement.getAttribute('cy'));

                // æ·»åŠ å…¨å±€ç›‘å¬å™¨ä»¥æ•è·SVGå¤–çš„ç§»åŠ¨å’ŒæŠ¬èµ·
                document.addEventListener('mousemove', drag);
                document.addEventListener('touchmove', drag, { passive: false }); // Handle touch
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchend', endDrag); // Handle touch end
                 event.preventDefault(); // Prevent default drag behavior or text selection
                 if (event.type === 'touchmove') {
                    event.preventDefault(); // Prevent scrolling on touch devices
                }
            }
        }

        function drag(event) {
            if (draggedElement) {
                event.preventDefault(); // é˜»æ­¢é»˜è®¤æ»šåŠ¨ç­‰è¡Œä¸º
                const coord = getSVGPoint(event);
                const newX = coord.x - offset.x;
                const newY = coord.y - offset.y;

                // è°ƒç”¨å½“å‰å½¢çŠ¶çš„æ›´æ–°å‡½æ•°
                if (currentShape && shapesData[currentShape]?.update) {
                    shapesData[currentShape].update(draggedElement, newX, newY);
                    // å®æ—¶æ›´æ–°é¢ç§¯æ˜¾ç¤º
                    updateAreaDisplay();
                }
            }
        }

        function endDrag() {
            draggedElement = null;
            // ç§»é™¤å…¨å±€ç›‘å¬å™¨
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchend', endDrag);
        }

        // --- é¢ç§¯è®¡ç®—ä¸æ˜¾ç¤º ---
        function updateAreaDisplay() {
            if (currentShape && shapesData[currentShape]?.calculateArea) {
                const area = shapesData[currentShape].calculateArea();
                shapeAreaSpan.textContent = area.toFixed(1); // ä¿ç•™ä¸€ä½å°æ•°
                areaDisplay.style.display = 'block';
            } else {
                areaDisplay.style.display = 'none';
            }
        }

        // --- å½¢çŠ¶æ•°æ®ã€ç”Ÿæˆã€æ›´æ–°å’Œé¢ç§¯è®¡ç®— ---
        const shapesData = {
            square: {
                init: () => {
                    // å›ºå®šå·¦ä¸Šè§’ (A), æ‹–åŠ¨å³ä¸‹è§’ (C)
                    const A = { x: 50, y: 50 };
                    let side = 100;
                    const B = { x: A.x + side, y: A.y };
                    const C = { x: A.x + side, y: A.y + side };
                    const D = { x: A.x, y: A.y + side };

                    svgContainer.innerHTML = `
                        <rect id="shape-geom" class="shape" x="${A.x}" y="${A.y}" width="${side}" height="${side}" fill="#4CAF50" />
                        <circle id="handle-c" class="handle" cx="${C.x}" cy="${C.y}" r="5" data-point="C"/>
                        <!-- å¯ä»¥æ·»åŠ å…¶ä»–è¾…åŠ© handleï¼Œä½†åªè®©ä¸€ä¸ªå¯æ‹–åŠ¨æ¥ä¿æŒæ­£æ–¹å½¢ -->
                    `;
                    document.getElementById('handle-c').addEventListener('mousedown', startDrag);
                    document.getElementById('handle-c').addEventListener('touchstart', startDrag); // Handle touch start
                },
                update: (handle, newX, newY) => {
                    const shape = document.getElementById('shape-geom');
                    const handleC = document.getElementById('handle-c');
                    const A = { x: parseFloat(shape.getAttribute('x')), y: parseFloat(shape.getAttribute('y')) };

                    // è®¡ç®—æ–°çš„è¾¹é•¿ï¼Œå–Xå’ŒYå˜åŒ–é‡ä¸­çš„è¾ƒå¤§å€¼ï¼Œå¹¶ç¡®ä¿ä¸ºæ­£
                    let newSide = Math.max(newX - A.x, newY - A.y);
                    newSide = Math.max(5, newSide); // æœ€å°è¾¹é•¿

                    // æ›´æ–°çŸ©å½¢
                    shape.setAttribute('width', newSide);
                    shape.setAttribute('height', newSide);

                    // æ›´æ–°æ‹–åŠ¨ç‚¹ C çš„ä½ç½®
                    const C = { x: A.x + newSide, y: A.y + newSide };
                    handleC.setAttribute('cx', C.x);
                    handleC.setAttribute('cy', C.y);
                },
                calculateArea: () => {
                    const shape = document.getElementById('shape-geom');
                    const side = parseFloat(shape.getAttribute('width')); // å®½é«˜ç›¸ç­‰
                    // å°†SVGå•ä½ä¸‹çš„é¢ç§¯è½¬æ¢ä¸ºæ›´æ˜“ç†è§£çš„â€œåƒç´ å¹³æ–¹â€æ„Ÿè§‰ï¼Œå¯ä»¥ä¹˜ä»¥ä¸€ä¸ªæ¯”ä¾‹å› å­
                    const scaleFactor = 1; // ç®€å•ç¤ºä¾‹ï¼Œä¸ç¼©æ”¾
                    return side * side * scaleFactor;
                },
                explanation: `<h3>æ­£æ–¹å½¢ (Square)</h3>...` // (å†…å®¹åŒå‰)
            },
            rectangle: {
                init: () => {
                     // å›ºå®šå·¦ä¸Šè§’ (A), æ‹–åŠ¨å³ä¸‹è§’ (C)
                    const A = { x: 30, y: 60 };
                    let width = 140;
                    let height = 80;
                    const C = { x: A.x + width, y: A.y + height };

                    svgContainer.innerHTML = `
                        <rect id="shape-geom" class="shape" x="${A.x}" y="${A.y}" width="${width}" height="${height}" fill="#2196F3" />
                        <circle id="handle-c" class="handle" cx="${C.x}" cy="${C.y}" r="5" data-point="C"/>
                    `;
                    document.getElementById('handle-c').addEventListener('mousedown', startDrag);
                     document.getElementById('handle-c').addEventListener('touchstart', startDrag);
                },
                update: (handle, newX, newY) => {
                    const shape = document.getElementById('shape-geom');
                    const handleC = document.getElementById('handle-c');
                    const A = { x: parseFloat(shape.getAttribute('x')), y: parseFloat(shape.getAttribute('y')) };

                    let newWidth = Math.max(5, newX - A.x); // æœ€å°å®½åº¦
                    let newHeight = Math.max(5, newY - A.y); // æœ€å°é«˜åº¦

                    shape.setAttribute('width', newWidth);
                    shape.setAttribute('height', newHeight);

                    handleC.setAttribute('cx', A.x + newWidth);
                    handleC.setAttribute('cy', A.y + newHeight);
                },
                calculateArea: () => {
                    const shape = document.getElementById('shape-geom');
                    const width = parseFloat(shape.getAttribute('width'));
                    const height = parseFloat(shape.getAttribute('height'));
                    return width * height;
                },
                explanation: `<h3>é•¿æ–¹å½¢ (Rectangle)</h3>...` // (å†…å®¹åŒå‰)
            },
            triangle: {
                 // æ‹–åŠ¨ä¸‰ä¸ªé¡¶ç‚¹ A, B, C
                init: () => {
                    const points = [{x: 100, y: 30}, {x: 170, y: 170}, {x: 30, y: 170}]; // A, B, C
                    svgContainer.innerHTML = `
                        <polygon id="shape-geom" class="shape" points="${points.map(p => `${p.x},${p.y}`).join(' ')}" fill="#FFC107" />
                        <circle id="handle-a" class="handle" cx="${points[0].x}" cy="${points[0].y}" r="5" data-index="0"/>
                        <circle id="handle-b" class="handle" cx="${points[1].x}" cy="${points[1].y}" r="5" data-index="1"/>
                        <circle id="handle-c" class="handle" cx="${points[2].x}" cy="${points[2].y}" r="5" data-index="2"/>
                    `;
                    document.querySelectorAll('.handle').forEach(h => {
                         h.addEventListener('mousedown', startDrag);
                         h.addEventListener('touchstart', startDrag);
                    });
                },
                update: (handle, newX, newY) => {
                    const shape = document.getElementById('shape-geom');
                    const index = parseInt(handle.dataset.index);
                    const pointsStr = shape.getAttribute('points').split(' ');
                    const points = pointsStr.map(p => {
                        const coords = p.split(',');
                        return { x: parseFloat(coords[0]), y: parseFloat(coords[1]) };
                    });

                    // æ›´æ–°è¢«æ‹–åŠ¨ç‚¹çš„ä½ç½®
                    points[index] = { x: Math.max(0, Math.min(200, newX)), y: Math.max(0, Math.min(200, newY)) }; // é™åˆ¶åœ¨viewBoxå†…

                    // æ›´æ–° handle å’Œ polygon
                    handle.setAttribute('cx', points[index].x);
                    handle.setAttribute('cy', points[index].y);
                    shape.setAttribute('points', points.map(p => `${p.x},${p.y}`).join(' '));
                },
                calculateArea: () => {
                    // Shoelace Formula (é‹å¸¦å…¬å¼) è®¡ç®—ä»»æ„å¤šè¾¹å½¢é¢ç§¯
                    const shape = document.getElementById('shape-geom');
                    const pointsStr = shape.getAttribute('points').split(' ');
                    const points = pointsStr.map(p => {
                        const coords = p.split(',');
                        return { x: parseFloat(coords[0]), y: parseFloat(coords[1]) };
                    });
                    let area = 0;
                    let j = points.length - 1;
                    for (let i = 0; i < points.length; i++) {
                        area += (points[j].x + points[i].x) * (points[j].y - points[i].y);
                        j = i; // j is previous vertex to i
                    }
                    return Math.abs(area / 2);
                },
                explanation: `<h3>ä¸‰è§’å½¢ (Triangle)</h3>...` // (å†…å®¹åŒå‰)
            },
             parallelogram: {
                // ç®€åŒ–ï¼šå›ºå®šå·¦ä¸‹è§’(A)ï¼Œæ‹–åŠ¨å³ä¸‹è§’(B)æ”¹åº•è¾¹ï¼Œæ‹–åŠ¨å·¦ä¸Šè§’(D)æ”¹é«˜åº¦å’Œå€¾æ–œ
                init: () => {
                    let A = { x: 20, y: 150 };
                    let B = { x: 140, y: 150 }; // å³ä¸‹
                    let D = { x: 40, y: 50 };  // å·¦ä¸Š
                    let C = { x: B.x + (D.x - A.x), y: D.y }; // å³ä¸Š C = B + D - A

                    svgContainer.innerHTML = `
                        <polygon id="shape-geom" class="shape" points="${A.x},${A.y} ${B.x},${B.y} ${C.x},${C.y} ${D.x},${D.y}" fill="#9C27B0" />
                        <circle id="handle-b" class="handle" cx="${B.x}" cy="${B.y}" r="5" data-point="B"/>
                        <circle id="handle-d" class="handle" cx="${D.x}" cy="${D.y}" r="5" data-point="D"/>
                    `;
                    document.getElementById('handle-b').addEventListener('mousedown', startDrag);
                    document.getElementById('handle-d').addEventListener('mousedown', startDrag);
                     document.getElementById('handle-b').addEventListener('touchstart', startDrag);
                     document.getElementById('handle-d').addEventListener('touchstart', startDrag);
                },
                update: (handle, newX, newY) => {
                    const shape = document.getElementById('shape-geom');
                    const points = shape.getAttribute('points').split(' ').map(p => { const c=p.split(','); return {x: parseFloat(c[0]), y: parseFloat(c[1])}; });
                    let [A, B, C, D] = points; // è·å–å½“å‰é¡¶ç‚¹
                    const handleB = document.getElementById('handle-b');
                    const handleD = document.getElementById('handle-d');

                    if (handle.dataset.point === 'B') { // æ‹–åŠ¨B (å³ä¸‹)
                        B.x = Math.max(A.x + 10, newX); // Bä¸èƒ½è·‘åˆ°Aå·¦è¾¹
                        B.y = A.y; // ä¿æŒåº•è¾¹æ°´å¹³
                        C.x = B.x + (D.x - A.x); // æ›´æ–°Cçš„xåæ ‡
                        // C.y = D.y; // Cçš„yåæ ‡éšDå˜åŒ–

                    } else if (handle.dataset.point === 'D') { // æ‹–åŠ¨D (å·¦ä¸Š)
                        D.x = newX;
                        D.y = Math.min(A.y - 10, newY); // Dä¸èƒ½è·‘åˆ°Aä¸‹é¢
                        C.y = D.y; // æ›´æ–°Cçš„yåæ ‡
                        C.x = B.x + (D.x - A.x); // æ›´æ–°Cçš„xåæ ‡
                    }

                     // é™åˆ¶åœ¨ viewBox å†… (ç®€å•å¤„ç†)
                    B.x = Math.max(0, Math.min(200, B.x));
                    D.x = Math.max(0, Math.min(200, D.x));
                    D.y = Math.max(0, Math.min(200, D.y));
                    C.x = Math.max(0, Math.min(200, C.x));
                    C.y = Math.max(0, Math.min(200, C.y));


                    // æ›´æ–° handles
                    handleB.setAttribute('cx', B.x);
                    handleB.setAttribute('cy', B.y);
                    handleD.setAttribute('cx', D.x);
                    handleD.setAttribute('cy', D.y);

                    // æ›´æ–° polygon
                    shape.setAttribute('points', `${A.x},${A.y} ${B.x},${B.y} ${C.x},${C.y} ${D.x},${D.y}`);
                },
                calculateArea: () => {
                     const shape = document.getElementById('shape-geom');
                     const points = shape.getAttribute('points').split(' ').map(p => { const c=p.split(','); return {x: parseFloat(c[0]), y: parseFloat(c[1])}; });
                     const [A, B, C, D] = points;
                     const base = Math.abs(B.x - A.x);
                     const height = Math.abs(A.y - D.y); // å› ä¸ºå‡è®¾åº•è¾¹æ°´å¹³ï¼Œé«˜å°±æ˜¯yåæ ‡å·®
                     return base * height;
                },
                explanation: `<h3>å¹³è¡Œå››è¾¹å½¢ (Parallelogram)</h3>...` // (å†…å®¹åŒå‰)
            },
            trapezoid: {
                 // ç®€åŒ–ï¼šå›ºå®šåº•è¾¹yåæ ‡ï¼Œæ‹–åŠ¨ä¸Šåº•å·¦å³é¡¶ç‚¹(C,D)ï¼Œä¸‹åº•å·¦å³é¡¶ç‚¹(A,B)
                 init: () => {
                    let A = { x: 20, y: 150 }; // å·¦ä¸‹
                    let B = { x: 180, y: 150 }; // å³ä¸‹
                    let C = { x: 150, y: 50 }; // å³ä¸Š
                    let D = { x: 50, y: 50 };  // å·¦ä¸Š

                    svgContainer.innerHTML = `
                        <polygon id="shape-geom" class="shape" points="${A.x},${A.y} ${B.x},${B.y} ${C.x},${C.y} ${D.x},${D.y}" fill="#E91E63" />
                        <circle id="handle-a" class="handle" cx="${A.x}" cy="${A.y}" r="5" data-point="A"/>
                        <circle id="handle-b" class="handle" cx="${B.x}" cy="${B.y}" r="5" data-point="B"/>
                        <circle id="handle-c" class="handle" cx="${C.x}" cy="${C.y}" r="5" data-point="C"/>
                        <circle id="handle-d" class="handle" cx="${D.x}" cy="${D.y}" r="5" data-point="D"/>
                    `;
                     document.querySelectorAll('.handle').forEach(h => {
                         h.addEventListener('mousedown', startDrag);
                         h.addEventListener('touchstart', startDrag);
                     });
                },
                update: (handle, newX, newY) => {
                    const shape = document.getElementById('shape-geom');
                    const points = shape.getAttribute('points').split(' ').map(p => { const c=p.split(','); return {x: parseFloat(c[0]), y: parseFloat(c[1])}; });
                    let [A, B, C, D] = points;
                    const pointId = handle.dataset.point;
                    const handleElement = document.getElementById(`handle-${pointId.toLowerCase()}`);

                    const topY = D.y; // ä¸Šåº• Y åæ ‡ (å›ºå®š)
                    const bottomY = A.y; // ä¸‹åº• Y åæ ‡ (å›ºå®š)

                    // æ›´æ–°å¯¹åº”é¡¶ç‚¹Xåæ ‡ï¼ŒYåæ ‡å›ºå®šä¸ºä¸Šåº•æˆ–ä¸‹åº•
                    if (pointId === 'A') A.x = newX;
                    else if (pointId === 'B') B.x = newX;
                    else if (pointId === 'C') C.x = newX;
                    else if (pointId === 'D') D.x = newX;

                    // ç¡®ä¿åº•è¾¹é¡¶ç‚¹ä¸äº¤å‰ï¼Œä¸Šåº•é¡¶ç‚¹ä¸äº¤å‰ (ç®€å•å¤„ç†)
                    if (A.x > B.x - 10) A.x = B.x - 10;
                    if (B.x < A.x + 10) B.x = A.x + 10;
                    if (D.x > C.x - 10) D.x = C.x - 10;
                    if (C.x < D.x + 10) C.x = D.x + 10;

                    // é™åˆ¶åœ¨ viewBox å†…
                    [A, B, C, D].forEach(p => {
                        p.x = Math.max(0, Math.min(200, p.x));
                    });

                    // æ›´æ–° Handle ä½ç½® (ä»…Xå˜åŒ–)
                    handleElement.setAttribute('cx', newX);
                    // handleElement.setAttribute('cy', pointId === 'A' || pointId === 'B' ? bottomY : topY); // Yä¸å˜


                    // æ›´æ–° polygon
                    shape.setAttribute('points', `${A.x},${A.y} ${B.x},${B.y} ${C.x},${C.y} ${D.x},${D.y}`);
                },
                calculateArea: () => {
                     const shape = document.getElementById('shape-geom');
                     const points = shape.getAttribute('points').split(' ').map(p => { const c=p.split(','); return {x: parseFloat(c[0]), y: parseFloat(c[1])}; });
                     const [A, B, C, D] = points;
                     const base1 = Math.abs(B.x - A.x); // ä¸‹åº•
                     const base2 = Math.abs(C.x - D.x); // ä¸Šåº•
                     const height = Math.abs(A.y - D.y); // é«˜åº¦
                     return (base1 + base2) * height / 2;
                },
                explanation: `<h3>æ¢¯å½¢ (Trapezoid)</h3>...` // (å†…å®¹åŒå‰)
            }
            // ... (å¯ä»¥ç»§ç»­æ·»åŠ å…¶ä»–å½¢çŠ¶)
        };

        // å¡«å……è®²è§£å†…å®¹ (ä¹‹å‰å¿˜äº†æ”¾å›å»)
        shapesData.square.explanation = `
            <h3>æ­£æ–¹å½¢ (Square)</h3>
            <p>æ‹–åŠ¨å³ä¸‹è§’çš„ç‚¹ç‚¹ï¼Œçœ‹çœ‹æ­£æ–¹å½¢æ€ä¹ˆå˜ï¼</p>
            <ul>
                <li>å®ƒæœ‰ <strong>4</strong> æ¡è¾¹ï¼Œå¹¶ä¸”è¿™ <strong>4</strong> æ¡è¾¹éƒ½ä¸€æ ·é•¿ã€‚</li>
                <li>å®ƒæœ‰ <strong>4</strong> ä¸ªè§’ï¼Œè€Œä¸”è¿™ <strong>4</strong> ä¸ªè§’éƒ½æ˜¯ç›´è§’ã€‚</li>
                <li>å¯¹è¾¹æ˜¯äº’ç›¸å¹³è¡Œçš„ã€‚</li>
            </ul>`;
         shapesData.rectangle.explanation = `
            <h3>é•¿æ–¹å½¢ (Rectangle)</h3>
            <p>æ‹–åŠ¨å³ä¸‹è§’çš„ç‚¹ç‚¹ï¼Œå¯ä»¥æ”¹å˜å®ƒçš„é•¿å’Œå®½ï¼</p>
            <ul>
                <li>å®ƒä¹Ÿæœ‰ <strong>4</strong> æ¡è¾¹å’Œ <strong>4</strong> ä¸ªç›´è§’ã€‚</li>
                <li>å®ƒåªæœ‰<strong>å¯¹è¾¹</strong>çš„é•¿åº¦æ˜¯ç›¸ç­‰çš„ã€‚</li>
                <li>å¯¹è¾¹ä¹Ÿæ˜¯äº’ç›¸å¹³è¡Œçš„ã€‚</li>
            </ul>`;
        shapesData.triangle.explanation = `
            <h3>ä¸‰è§’å½¢ (Triangle)</h3>
            <p>æ‹–åŠ¨å®ƒçš„ä¸‰ä¸ªé¡¶ç‚¹ï¼Œå¯ä»¥åˆ›é€ å‡ºå„ç§å„æ ·çš„ä¸‰è§’å½¢ï¼</p>
            <ul>
                <li>å®ƒç”± <strong>3</strong> æ¡è¾¹ç»„æˆã€‚</li>
                <li>å®ƒæœ‰ <strong>3</strong> ä¸ªè§’ã€‚</li>
                <li>è¯•è¯•çœ‹èƒ½ä¸èƒ½æ‹¼å‡ºä¸€ä¸ªç›´è§’ä¸‰è§’å½¢ï¼Ÿ</li>
            </ul>`;
        shapesData.parallelogram.explanation = `
            <h3>å¹³è¡Œå››è¾¹å½¢ (Parallelogram)</h3>
            <p>æ‹–åŠ¨ä¸Šé¢çš„ç‚¹å¯ä»¥æ”¹å˜å½¢çŠ¶ï¼Œæ‹–åŠ¨å³ä¸‹è§’çš„ç‚¹æ”¹å˜åº•è¾¹é•¿åº¦ã€‚</p>
            <ul>
                <li>å®ƒæœ‰ <strong>4</strong> æ¡è¾¹ï¼Œ<strong>å¯¹è¾¹</strong>äº’ç›¸å¹³è¡Œå¹¶ä¸”é•¿åº¦ç›¸ç­‰ã€‚</li>
                <li>å®ƒæœ‰ <strong>4</strong> ä¸ªè§’ï¼Œ<strong>å¯¹è§’</strong>çš„å¤§å°æ˜¯ç›¸ç­‰çš„ã€‚</li>
                <li>å®ƒçš„è§’ä¸ä¸€å®šæ˜¯ç›´è§’å“¦ï¼</li>
            </ul>`;
        shapesData.trapezoid.explanation = `
            <h3>æ¢¯å½¢ (Trapezoid)</h3>
            <p>æ‹–åŠ¨ä¸Šä¸‹åº•è¾¹ä¸¤ç«¯çš„ç‚¹ç‚¹ï¼Œæ”¹å˜æ¢¯å½¢çš„å½¢çŠ¶ï¼</p>
            <ul>
                <li>å®ƒæœ‰ <strong>4</strong> æ¡è¾¹ã€‚</li>
                <li>å®ƒ<strong>åªæœ‰ä¸€ç»„</strong>å¯¹è¾¹æ˜¯äº’ç›¸å¹³è¡Œçš„ï¼ˆä¸Šè¾¹å’Œä¸‹è¾¹ï¼‰ã€‚</li>
                <li>å¦å¤–ä¸¤æ¡è¾¹ï¼ˆè…°ï¼‰å¯èƒ½ä¸€æ ·é•¿ï¼Œä¹Ÿå¯èƒ½ä¸ä¸€æ ·é•¿ã€‚</li>
            </ul>`;


        // æ›´æ–°æ˜¾ç¤ºå†…å®¹çš„å‡½æ•° (å¢å¼ºç‰ˆ)
        function updateDisplay(shapeName) {
            const data = shapesData[shapeName];
            if (!data) return;

            currentShape = shapeName; // æ›´æ–°å½“å‰å½¢çŠ¶æ ‡è¯†

            // éšè—åˆå§‹æç¤º
            if (initialPrompt) {
                initialPrompt.style.display = 'none';
            }

            // ç”Ÿæˆ SVG å½¢çŠ¶å’Œ Handles
            if (data.init) {
                data.init();
            } else {
                svgContainer.innerHTML = ''; // æ¸…ç©ºæ— åˆå§‹åŒ–æ–¹æ³•çš„å½¢çŠ¶
            }


            // æ›´æ–°è®²è§£åŒºåŸŸ
            explanationContent.innerHTML = data.explanation;

            // æ›´æ–°å¹¶æ˜¾ç¤ºé¢ç§¯åŒºåŸŸ
            updateAreaDisplay();

            // æ›´æ–°æŒ‰é’®çš„é€‰ä¸­çŠ¶æ€
            shapeButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.shape === shapeName);
            });
        }

        // ä¸ºæ¯ä¸ªæŒ‰é’®æ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨
        shapeButtons.forEach(button => {
            button.addEventListener('click', () => {
                const shape = button.dataset.shape;
                updateDisplay(shape);
            });
        });

        // é¡µé¢åŠ è½½æ—¶ä¸æ˜¾ç¤ºä»»ä½•å½¢çŠ¶ï¼Œä¿ç•™æç¤º
    </script>

</body>
</html>