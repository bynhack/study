<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>正方体切割表面积增加演示 (点击交互)</title>
    <!-- Google Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- (Keep all the CSS from the previous 'modern UI' version) --- */
        :root {
            --primary-color: #007bff; /* A nice blue */
            --secondary-color: #6c757d; /* Grey */
            --bg-light: #f8f9fa; /* Light background */
            --bg-white: #ffffff;
            --text-dark: #343a40;
            --text-light: #f8f9fa;
            --border-color: #dee2e6;
            --shadow-sm: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
            --shadow-md: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
            --font-family-sans-serif: 'Nunito', sans-serif;
            --original-surface: #6495ED; /* CornflowerBlue */
            --new-surface: #FA8072; /* Salmon */
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            font-family: var(--font-family-sans-serif);
            background-color: var(--bg-light);
            color: var(--text-dark);
            display: flex;
            height: 100vh;
            overflow: hidden; /* Prevent body scroll */
        }

        #info-panel {
            width: 600px; /* Slightly wider */
            flex-shrink: 0; /* Prevent shrinking */
            background-color: var(--bg-white);
            padding: 25px;
            overflow-y: auto; /* Scroll if content overflows */
            box-shadow: var(--shadow-md);
            z-index: 10; /* Ensure it's above canvas visually */
            display: flex;
            flex-direction: column;
        }

        #info-panel h2 {
            margin-top: 0; color: var(--primary-color); font-weight: 700;
            border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 20px;
        }
        #info-panel h3 { margin-top: 25px; margin-bottom: 10px; color: var(--text-dark); font-weight: 600; }
        #info-panel p { line-height: 1.6; margin-bottom: 15px; }
        #info-panel b, #info-panel strong { font-weight: 700; }
        .highlight { color: var(--new-surface); font-weight: 700; background-color: #fceae9; padding: 2px 5px; border-radius: 4px; }
        .color-key span { display: inline-block; width: 14px; height: 14px; border-radius: 3px; margin-right: 8px; vertical-align: middle; border: 1px solid rgba(0,0,0,0.1); }
        .original-color-bg { background-color: var(--original-surface); }
        .new-color-bg { background-color: var(--new-surface); }
        hr { border: 0; height: 1px; background-color: var(--border-color); margin: 25px 0; }

        #interaction-info {
            font-size: 0.9em;
            color: var(--secondary-color);
            margin-top: 10px;
            background-color: var(--bg-light);
            padding: 8px;
            border-radius: 4px;
        }

        #resetButton {
            display: block; padding: 12px 20px; margin-top: auto; background-color: var(--primary-color);
            color: var(--text-light); border: none; border-radius: 6px; cursor: pointer; font-size: 1em;
            font-weight: 600; text-align: center; transition: background-color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: var(--shadow-sm);
        }
        #resetButton:hover { background-color: #0056b3; box-shadow: 0 0.25rem 0.5rem rgba(0, 0, 0, 0.1); }

        #container { flex-grow: 1; position: relative; min-width: 0; }
        canvas { display: block; }

        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 20; display: flex; justify-content: center; align-items: center; width: 60px; height: 60px; }
        .spinner { border: 5px solid var(--bg-light); border-top: 5px solid var(--primary-color); border-radius: 50%; width: 100%; height: 100%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="info-panel">
        <h2>正方体切割与表面积</h2>
        <div> <!-- Scrollable content area -->
            <h3>初始状态</h3>
            <p>一个正方体木块，总表面积为 <b>36</b> 平方厘米。</p>
            <p>它有 6 个相同的面，因此每个面的面积是 36 / 6 = <b>6</b> 平方厘米。</p>

            <h3>切割过程</h3>
            <p>要将它切割成 8 个相等的小正方体，需要沿着长、宽、高三个方向各切一刀，共 <b>3</b> 刀。</p>

            <hr>

            <h3>关键原理</h3>
            <p>每一次切割，都会产生 <b>2</b> 个新的内部表面。</p>
             <p>所以，每切一刀会增加 <strong style="color: var(--primary-color)">2 × 6 = 12 cm²</strong> 的表面积。</p>


            <h3>计算结果</h3>
            <p>总共切了 <b>3</b> 刀。</p>
            <p>总增加表面积 = 3 刀 × 12 cm²/刀 = <span class="highlight">36 平方厘米</span>。</p>

            <hr>

            <h3>可视化说明</h3>
            <p class="color-key"><span class="original-color-bg"></span> 代表 <b>原始</b> 的外表面。</p>
            <p class="color-key"><span class="new-color-bg"></span> 代表切割后 <b>新增</b> 的内表面。</p>
            <p id="interaction-info">
                提示：点击右侧任意一个小方块可以高亮显示它，再次点击或点击背景取消高亮。
            </p>
        </div>
        <button id="resetButton">重置动画和视角</button>
    </div>

    <div id="container">
         <div id="loading"><div class="spinner"></div></div>
    </div>

    <!-- Three.js Library (using CDN) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let cubes = []; // Array to hold the 8 small cube Meshes
        const clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster(); // For picking
        const pointer = new THREE.Vector2(); // Mouse coordinates in NDC
        let selectedCube = null; // To store the currently highlighted cube

        // --- Configuration ---
        const largeCubeSize = 2;
        const smallCubeSize = largeCubeSize / 2;
        const gap = smallCubeSize * 0.15;
        const animationDuration = 1.5;
        const originalOpacity = 1.0;
        const weakenedOpacity = 0.15; // Make non-selected cubes quite faint

        // --- Materials (MUST be transparent for opacity changes) ---
        const originalMaterialTemplate = new THREE.MeshStandardMaterial({
            color: 0x6495ED, roughness: 0.6, metalness: 0.1,
            transparent: true, opacity: originalOpacity // Enable transparency
        });
        const newMaterialTemplate = new THREE.MeshStandardMaterial({
            color: 0xFA8072, roughness: 0.6, metalness: 0.1,
            transparent: true, opacity: originalOpacity // Enable transparency
        });

        const targetPositions = [];
        const initialPositions = [];
        const initialCameraPosition = new THREE.Vector3(largeCubeSize * 1.8, largeCubeSize * 1.6, largeCubeSize * 2.8);

        // --- Initialization ---
        function init() {
            const container = document.getElementById('container');
            const loadingElement = document.getElementById('loading');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(getComputedStyle(document.body).getPropertyValue('--bg-light').trim());

            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.copy(initialCameraPosition); // Use stored initial position

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // --- Lighting (same as before) ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(5, 10, 7);
            scene.add(directionalLight1);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-5, -5, -5);
            scene.add(directionalLight2);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0, 0);
            controls.maxPolarAngle = Math.PI * 0.85;
            controls.minDistance = largeCubeSize * 1.5;
            controls.maxDistance = largeCubeSize * 5;

            createCubes();

            loadingElement.style.display = 'none';

            window.addEventListener('resize', onWindowResize, false);
            // Use pointerdown for potentially better responsiveness on touch/pen
            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
            document.getElementById('resetButton').addEventListener('click', resetView);

            startAnimation();
            animate();
        }

        // --- Create the 8 Cubes ---
        function createCubes() {
            cubes = []; // Clear existing cubes if any
            const smallGeo = new THREE.BoxGeometry(smallCubeSize, smallCubeSize, smallCubeSize);

            let index = 0;
            for (let i = 0; i < 2; i++) { // x
                for (let j = 0; j < 2; j++) { // y
                    for (let k = 0; k < 2; k++) { // z
                        // Create UNIQUE material instances for each face by cloning
                        // This is important if we ever wanted per-face opacity control,
                        // but also good practice here.
                         const materials = [
                            (i === 1 ? newMaterialTemplate : originalMaterialTemplate).clone(), // Right (+x)
                            (i === 0 ? newMaterialTemplate : originalMaterialTemplate).clone(), // Left (-x)
                            (j === 1 ? newMaterialTemplate : originalMaterialTemplate).clone(), // Top (+y)
                            (j === 0 ? newMaterialTemplate : originalMaterialTemplate).clone(), // Bottom (-y)
                            (k === 1 ? newMaterialTemplate : originalMaterialTemplate).clone(), // Front (+z)
                            (k === 0 ? newMaterialTemplate : originalMaterialTemplate).clone()  // Back (-z)
                        ];

                        // Ensure cloned materials are also transparent
                         materials.forEach(mat => {
                             mat.transparent = true;
                             mat.opacity = originalOpacity;
                         });

                        const cube = new THREE.Mesh(smallGeo, materials);

                        const initialX = (i - 0.5) * smallCubeSize;
                        const initialY = (j - 0.5) * smallCubeSize;
                        const initialZ = (k - 0.5) * smallCubeSize;
                        const targetX = (i - 0.5) * (smallCubeSize + gap);
                        const targetY = (j - 0.5) * (smallCubeSize + gap);
                        const targetZ = (k - 0.5) * (smallCubeSize + gap);

                        cube.position.set(initialX, initialY, initialZ);
                        initialPositions[index] = new THREE.Vector3(initialX, initialY, initialZ);
                        targetPositions[index] = new THREE.Vector3(targetX, targetY, targetZ);

                        cubes.push(cube);
                        scene.add(cube);
                        index++;
                    }
                }
            }
            selectedCube = null; // Ensure no cube is selected initially
        }

        // --- Handle Pointer Down (Click/Tap) ---
        function onPointerDown(event) {
            // Calculate pointer position in normalized device coordinates (-1 to +1)
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // Update the picking ray with the camera and pointer position
            raycaster.setFromCamera(pointer, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(cubes); // Only check our cubes

            if (intersects.length > 0) {
                const clickedObj = intersects[0].object; // The closest intersected cube

                // If nothing is selected, select the clicked one
                if (selectedCube === null) {
                    selectedCube = clickedObj;
                    highlightCube(selectedCube);
                }
                // If the *same* cube is clicked again, deselect it
                else if (selectedCube === clickedObj) {
                    unhighlightAllCubes();
                }
                // If a *different* cube is clicked, deselect the old and select the new
                else {
                    unhighlightAllCubes(); // Deselect previous first
                    selectedCube = clickedObj;
                    highlightCube(selectedCube);
                }
            } else {
                // Clicked on the background, deselect if something was selected
                if (selectedCube !== null) {
                    unhighlightAllCubes();
                }
            }
        }

        // --- Highlight/Unhighlight Functions ---
        function highlightCube(cubeToHighlight) {
            cubes.forEach(cube => {
                const opacity = (cube === cubeToHighlight) ? originalOpacity : weakenedOpacity;
                 // cube.material is an array here
                 cube.material.forEach(mat => mat.opacity = opacity);
            });
        }

        function unhighlightAllCubes() {
            cubes.forEach(cube => {
                 cube.material.forEach(mat => mat.opacity = originalOpacity);
            });
            selectedCube = null; // Reset selection state
        }


        // --- Animation Logic ---
        let animationStartTime = 0;
        let isAnimating = false;

        function startAnimation() {
            if (isAnimating) return; // Prevent restarting if already running
            console.log("Starting animation...");
            unhighlightAllCubes(); // Ensure nothing is highlighted during animation reset
            isAnimating = true;
            for (let i = 0; i < cubes.length; i++) {
                if (cubes[i] && initialPositions[i]) {
                     cubes[i].position.copy(initialPositions[i]);
                     // Reset opacity fully before animation starts
                     cubes[i].material.forEach(mat => mat.opacity = originalOpacity);
                }
            }
            animationStartTime = clock.getElapsedTime();
        }

        function updateAnimation() {
            if (!isAnimating) return;
            const elapsedTime = clock.getElapsedTime() - animationStartTime;
            let progress = Math.min(elapsedTime / animationDuration, 1);
            progress = progress * progress * (3 - 2 * progress); // Smoothstep

            for (let i = 0; i < cubes.length; i++) {
                 if (cubes[i] && initialPositions[i] && targetPositions[i]) {
                    cubes[i].position.lerpVectors(initialPositions[i], targetPositions[i], progress);
                }
            }
            if (elapsedTime >= animationDuration) {
                isAnimating = false;
                console.log("Animation finished.");
                // Snap to final position and ensure correct opacity
                for (let i = 0; i < cubes.length; i++) {
                     if (cubes[i] && targetPositions[i]) {
                        cubes[i].position.copy(targetPositions[i]);
                        // Check if a cube should be highlighted post-animation
                        const targetOpacity = (selectedCube === cubes[i]) ? originalOpacity : (selectedCube ? weakenedOpacity : originalOpacity);
                         cubes[i].material.forEach(mat => mat.opacity = targetOpacity);
                     }
                }
                 // Re-apply highlighting if needed after animation finishes
                 if(selectedCube) {
                     highlightCube(selectedCube);
                 }
            }
        }

        // --- Reset View Function ---
        function resetView() {
            startAnimation(); // Restart the separation animation
            // Reset camera and controls smoothly (optional, but nice)
            // controls.reset(); // This snaps instantly
             // Smooth reset requires tweening library or manual interpolation - keeping simple for now
             camera.position.copy(initialCameraPosition);
             controls.target.set(0,0,0);
             controls.update();
             unhighlightAllCubes(); // Ensure nothing is selected
        }


        // --- Render Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateAnimation();
            renderer.render(scene, camera);
        }

        // --- Window Resize Handler ---
        function onWindowResize() {
            const container = document.getElementById('container');
            if (!container) return;
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // --- Start everything ---
         try {
            init();
        } catch (error) {
            console.error("Initialization failed:", error);
            const loadingElement = document.getElementById('loading');
            if(loadingElement) { loadingElement.innerHTML = "加载失败: " + error.message; loadingElement.style.color = "red"; loadingElement.style.width = "auto"; loadingElement.style.height = "auto"; loadingElement.style.textAlign = "center"; }
        }

    </script>
</body>
</html>