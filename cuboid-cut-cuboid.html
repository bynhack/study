<!DOCTYPE html>
<html lang="zh">
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>长方体切割演示</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
         :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --bg-light: #f8f9fa;
            --bg-white: #ffffff;
            --text-dark: #343a40;
            --text-light: #f8f9fa;
            --border-color: #dee2e6;
            --shadow-sm: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
            --shadow-md: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
            --font-family-sans-serif: 'Nunito', sans-serif;
            --original-surface: #6495ED;
            --new-surface: #FA8072;
            --input-bg: #e9ecef;
        }
        * { box-sizing: border-box; }
         body { margin: 0; font-family: var(--font-family-sans-serif); background-color: var(--bg-light); color: var(--text-dark); display: flex; height: 100vh; overflow: hidden; }
         #info-panel { width: 450px; flex-shrink: 0; background-color: var(--bg-white); padding: 25px; overflow-y: auto; box-shadow: var(--shadow-md); z-index: 10; display: flex; flex-direction: column; }
         #info-panel h2 { margin-top: 0; color: var(--primary-color); font-weight: 700; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 20px; }
         #info-panel h3 { margin-top: 25px; margin-bottom: 10px; color: var(--text-dark); font-weight: 600; }
         #info-panel p { line-height: 1.6; margin-bottom: 15px; }
         #info-panel b, #info-panel strong { font-weight: 700; }
         .highlight { color: var(--new-surface); font-weight: 700; background-color: #fceae9; padding: 2px 5px; border-radius: 4px; }
         .color-key span { display: inline-block; width: 14px; height: 14px; border-radius: 3px; margin-right: 8px; vertical-align: middle; border: 1px solid rgba(0,0,0,0.1); }
         .original-color-bg { background-color: var(--original-surface); }
         .new-color-bg { background-color: var(--new-surface); }
         hr { border: 0; height: 1px; background-color: var(--border-color); margin: 25px 0; }
         #interaction-info { font-size: 0.9em; color: var(--secondary-color); margin-top: 10px; background-color: var(--bg-light); padding: 8px; border-radius: 4px; }
         #resetButton { display: block; padding: 12px 20px; margin-top: auto; background-color: var(--primary-color); color: var(--text-light); border: none; border-radius: 6px; cursor: pointer; font-size: 1em; font-weight: 600; text-align: center; transition: background-color 0.2s ease, box-shadow 0.2s ease; box-shadow: var(--shadow-sm); }
         #resetButton:hover { background-color: #0056b3; box-shadow: 0 0.25rem 0.5rem rgba(0, 0, 0, 0.1); }
         #container { flex-grow: 1; position: relative; min-width: 0; }
         canvas { display: block; }
         #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 20; display: flex; justify-content: center; align-items: center; width: 60px; height: 60px; }
         .spinner { border: 5px solid var(--bg-light); border-top: 5px solid var(--primary-color); border-radius: 50%; width: 100%; height: 100%; animation: spin 1s linear infinite; }
         @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
         .input-group { margin-bottom: 15px; }
         .input-group label { display: block; font-weight: 600; margin-bottom: 5px; font-size: 0.9em; color: var(--secondary-color); }
         .input-group input[type="number"] { width: 100%; padding: 8px 10px; border: 1px solid var(--border-color); border-radius: 4px; font-family: inherit; font-size: 0.95em; background-color: var(--input-bg); }
         .input-group input:focus { outline: none; border-color: var(--primary-color); background-color: var(--bg-white); box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25); }
         #error { color: red; font-weight: bold; margin-top: 10px; font-size: 0.9em; }
        .formula { padding: 10px; background: #fff; border-left: 4px solid var(--primary-color); margin: 10px 0; font-family: 'Courier New', monospace; }
        .calculation { margin-top: 20px; padding: 15px; background: var(--bg-light); border-radius: 6px; }
         details { margin: 15px 0; border: 1px solid var(--border-color); border-radius: 4px; padding: 10px; }
         summary { font-weight: 600; cursor: pointer; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="info-panel">
        
        
            <h2>📐 立方体参数</h2>
            
            <div class="input-group">
                <h3>原立方体</h3>
                <label>长度 (L): <input type="number" id="orig-l" value="10" min="1"></label>
                <label>宽度 (W): <input type="number" id="orig-w" value="10" min="1"></label>
                <label>高度 (H): <input type="number" id="orig-h" value="10" min="1"></label>
            </div>

            <div class="input-group">
                <h3>切割立方体</h3>
                <label>位置 X: <input type="number" id="cut-x" value="2" min="0"></label>
                <label>位置 Y: <input type="number" id="cut-y" value="2" min="0"></label>
                <label>位置 Z: <input type="number" id="cut-z" value="2" min="0"></label>
                <label>长度: <input type="number" id="cut-l" value="6" min="1"></label>
                <label>宽度: <input type="number" id="cut-w" value="6" min="1"></label>
                <label>高度: <input type="number" id="cut-h" value="6" min="1"></label>
            </div>

            <div id="error"></div>

            <div class="calculation">
                <h3>🔍 计算结果</h3>
                <p>剩余体积: <span id="volume">0</span></p>
                <p>表面积: <span id="surface">0</span></p>
            </div>

            <details open>
                <summary>📖 计算步骤</summary>
                <div id="calculation-steps"></div>
            </details>

            <details>
                <summary>📚 数学概念</summary>
                <div class="concept">
                    <h4>体积计算</h4>
                    <p>体积公式：V = L × W × H</p>
                    <p>剩余体积 = 原体积 - 切割体积</p>

                    <h4>表面积变化</h4>
                    <p>总表面积 = 原表面积 + 切割体暴露面 - 2×接触面积</p>
                    <p>接触面积判定：当切割立方体与原立方体的面完全对齐时产生接触</p>
                </div>
            </details>
        </div>
       

        <div id="container"><div id="loading"><div class="spinner"></div></div></div>
    </div>

    <script>
         let scene, camera, renderer, controls;
        let origCube, cutCube;

        // 初始化Three.js场景
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xecf0f1);

            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(25, 25, 25);

            renderer = new THREE.WebGLRenderer({ antialias: true });
             renderer.setSize(
                 document.getElementById('container').clientWidth,
                 document.getElementById('container').clientHeight
             );
             document.getElementById('container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // 照明设置
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 15);
            scene.add(directionalLight);
            document.getElementById('loading').style.display = 'none';
            animate();
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // 创建/更新立方体
        function updateCubes() {
            // 清除旧物体
            if (origCube) scene.remove(origCube);
            if (cutCube) scene.remove(cutCube);

            // 获取输入值
            const origL = parseFloat(document.getElementById('orig-l').value);
            const origW = parseFloat(document.getElementById('orig-w').value);
            const origH = parseFloat(document.getElementById('orig-h').value);
            const cutX = parseFloat(document.getElementById('cut-x').value);
            const cutY = parseFloat(document.getElementById('cut-y').value);
            const cutZ = parseFloat(document.getElementById('cut-z').value);
            const cutL = parseFloat(document.getElementById('cut-l').value);
            const cutW = parseFloat(document.getElementById('cut-w').value);
            const cutH = parseFloat(document.getElementById('cut-h').value);

            // 错误检测
            const errorElement = document.getElementById('error');
            if (cutX + cutL > origL || cutY + cutW > origW || cutZ + cutH > origH) {
                errorElement.textContent = "错误：切割立方体超出原立方体范围！";
                errorElement.style.display = 'block';
                return;
            }
            errorElement.style.display = 'none';

            // 创建原立方体（带透明度的蓝色面）
            const origGeometry = new THREE.BoxGeometry(origL, origH, origW);
            const origMaterial = new THREE.MeshPhongMaterial({
                color: 0x3498db,  // 使用蓝色
                wireframe: false,   // 关闭线框模式
                transparent: true,
                opacity: 0.2,      // 进一步降低透明度
                side: THREE.DoubleSide,  // 双面渲染
                specular: 0x222222,
                shininess: 50
            });
            origCube = new THREE.Mesh(origGeometry, origMaterial);
            scene.add(origCube);

            // 创建切割立方体
            const cutGeometry = new THREE.BoxGeometry(cutL, cutH, cutW);
            const cutMaterial = new THREE.MeshPhongMaterial({
                color: 0xe74c3c,
                transparent: true,
                opacity: 0.9,      // 增加不透明度
                side: THREE.DoubleSide,  // 双面渲染
                depthWrite: false  // 禁用深度写入
            });
            cutCube = new THREE.Mesh(cutGeometry, cutMaterial);
            cutCube.position.set(
                cutX + cutL/2 - origL/2,
                cutY + cutH/2 - origH/2,
                cutZ + cutW/2 - origW/2
            );
            scene.add(cutCube);

            // 计算并显示结果
            updateCalculations(origL, origW, origH, cutX, cutY, cutZ, cutL, cutW, cutH);
        }

        // 更新计算说明
        function updateCalculations(origL, origW, origH, cutX, cutY, cutZ, cutL, cutW, cutH) {
            // 体积计算
            const origVolume = origL * origW * origH;
            const cutVolume = cutL * cutW * cutH;
            const remainingVolume = origVolume - cutVolume;

            // 表面积计算
            let contactFaces = 0;
            const contactTests = [
                { axis: 'x', pos: cutX },                       // 左面检测
                { axis: 'x', pos: origL - (cutX + cutL) },      // 右面检测
                { axis: 'y', pos: cutY },                       // 前面检测
                { axis: 'y', pos: origW - (cutY + cutW) },     // 后面检测
                { axis: 'z', pos: cutZ },                       // 底面检测
                { axis: 'z', pos: origH - (cutZ + cutH) }      // 顶面检测
            ];

            contactTests.forEach(test => {
                if (test.pos === 0) {
                    switch(test.axis) {
                        case 'x': contactFaces += cutW * cutH; break;
                        case 'y': contactFaces += cutL * cutH; break;
                        case 'z': contactFaces += cutL * cutW; break;
                    }
                }
            });

            const origSurface = 2 * (origL*origW + origL*origH + origW*origH);
            const cutSurface = 2 * (cutL*cutW + cutL*cutH + cutW*cutH);
            const totalSurface = origSurface + cutSurface - 2 * contactFaces;

            // 更新显示
            document.getElementById('volume').textContent = remainingVolume.toFixed(2);
            document.getElementById('surface').textContent = totalSurface.toFixed(2);

            // 生成计算步骤
            const stepsHTML = `
                <div class="formula">
                    原体积 = L × W × H = 
                    ${origL} × ${origW} × ${origH} = 
                    <span class="highlight">${origVolume.toFixed(2)}</span>
                </div>

                <div class="formula">
                    切割体积 = l × w × h = 
                    ${cutL} × ${cutW} × ${cutH} = 
                    <span class="highlight">${cutVolume.toFixed(2)}</span>
                </div>

                <div class="formula">
                    剩余体积 = ${origVolume.toFixed(2)} - ${cutVolume.toFixed(2)} = 
                    <span class="highlight">${remainingVolume.toFixed(2)}</span>
                </div>

                <hr>

                <div class="formula">
                    原表面积 = 2(LW + LH + WH) = 
                    2(${origL}×${origW} + ${origL}×${origH} + ${origW}×${origH}) = 
                    <span class="highlight">${origSurface.toFixed(2)}</span>
                </div>

                <div class="formula">
                    切割体表面积 = 2(lw + lh + wh) = 
                    2(${cutL}×${cutW} + ${cutL}×${cutH} + ${cutW}×${cutH}) = 
                    <span class="highlight">${cutSurface.toFixed(2)}</span>
                </div>

                <div class="formula">
                    接触面积 = ${contactFaces.toFixed(2)} ⇒ 扣除 2 × ${contactFaces.toFixed(2)} = 
                    <span class="highlight">${(2*contactFaces).toFixed(2)}</span>
                </div>

                <div class="formula">
                    最终表面积 = ${origSurface.toFixed(2)} + ${cutSurface.toFixed(2)} - ${(2*contactFaces).toFixed(2)} = 
                    <span class="highlight">${totalSurface.toFixed(2)}</span>
                </div>
            `;

            document.getElementById('calculation-steps').innerHTML = stepsHTML;
        }

        // 窗口大小调整处理
        window.addEventListener('resize', () => {
             camera.aspect = document.getElementById('container').clientWidth /
                            document.getElementById('container').clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(
                 document.getElementById('container').clientWidth,
                 document.getElementById('container').clientHeight
            );
         });
        
        try {
            // 初始化
            initThree();
            updateCubes();
    
            // 添加输入监听
            document.querySelectorAll('input').forEach(input => {
                input.addEventListener('input', updateCubes);
            });
        }
        catch (error) {
            console.error("Initialization failed:", error);
        }
    </script>
</body>
</html>